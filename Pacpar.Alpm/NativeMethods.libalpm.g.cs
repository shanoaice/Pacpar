// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981
using System;
using System.Runtime.InteropServices;


namespace Pacpar.Alpm
{
    public static unsafe partial class NativeMethods
    {
        const string __DllName = "libalpm";





        [DllImport(__DllName, EntryPoint = "alpm_list_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void alpm_list_free(_alpm_list_t* list);

        [DllImport(__DllName, EntryPoint = "alpm_list_free_inner", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void alpm_list_free_inner(_alpm_list_t* list, delegate* unmanaged[Cdecl]<void*, void> fn_);

        [DllImport(__DllName, EntryPoint = "alpm_list_add", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_add(_alpm_list_t* list, void* data);

        [DllImport(__DllName, EntryPoint = "alpm_list_append", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_append(_alpm_list_t** list, void* data);

        [DllImport(__DllName, EntryPoint = "alpm_list_append_strdup", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_append_strdup(_alpm_list_t** list, byte* data);

        [DllImport(__DllName, EntryPoint = "alpm_list_add_sorted", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_add_sorted(_alpm_list_t* list, void* data, delegate* unmanaged[Cdecl]<void*, void*, int> fn_);

        [DllImport(__DllName, EntryPoint = "alpm_list_join", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_join(_alpm_list_t* first, _alpm_list_t* second);

        [DllImport(__DllName, EntryPoint = "alpm_list_mmerge", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_mmerge(_alpm_list_t* left, _alpm_list_t* right, delegate* unmanaged[Cdecl]<void*, void*, int> fn_);

        [DllImport(__DllName, EntryPoint = "alpm_list_msort", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_msort(_alpm_list_t* list, nuint n, delegate* unmanaged[Cdecl]<void*, void*, int> fn_);

        [DllImport(__DllName, EntryPoint = "alpm_list_remove_item", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_remove_item(_alpm_list_t* haystack, _alpm_list_t* item);

        [DllImport(__DllName, EntryPoint = "alpm_list_remove", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_remove(_alpm_list_t* haystack, void* needle, delegate* unmanaged[Cdecl]<void*, void*, int> fn_, void** data);

        [DllImport(__DllName, EntryPoint = "alpm_list_remove_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_remove_str(_alpm_list_t* haystack, byte* needle, byte** data);

        [DllImport(__DllName, EntryPoint = "alpm_list_remove_dupes", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_remove_dupes(_alpm_list_t* list);

        [DllImport(__DllName, EntryPoint = "alpm_list_strdup", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_strdup(_alpm_list_t* list);

        [DllImport(__DllName, EntryPoint = "alpm_list_copy", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_copy(_alpm_list_t* list);

        [DllImport(__DllName, EntryPoint = "alpm_list_copy_data", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_copy_data(_alpm_list_t* list, nuint size);

        [DllImport(__DllName, EntryPoint = "alpm_list_reverse", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_reverse(_alpm_list_t* list);

        [DllImport(__DllName, EntryPoint = "alpm_list_nth", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_nth(_alpm_list_t* list, nuint n);

        [DllImport(__DllName, EntryPoint = "alpm_list_next", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_next(_alpm_list_t* list);

        [DllImport(__DllName, EntryPoint = "alpm_list_previous", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_previous(_alpm_list_t* list);

        [DllImport(__DllName, EntryPoint = "alpm_list_last", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_last(_alpm_list_t* list);

        [DllImport(__DllName, EntryPoint = "alpm_list_count", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint alpm_list_count(_alpm_list_t* list);

        [DllImport(__DllName, EntryPoint = "alpm_list_find", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void* alpm_list_find(_alpm_list_t* haystack, void* needle, delegate* unmanaged[Cdecl]<void*, void*, int> fn_);

        [DllImport(__DllName, EntryPoint = "alpm_list_find_ptr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void* alpm_list_find_ptr(_alpm_list_t* haystack, void* needle);

        [DllImport(__DllName, EntryPoint = "alpm_list_find_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_list_find_str(_alpm_list_t* haystack, byte* needle);

        [DllImport(__DllName, EntryPoint = "alpm_list_cmp_unsorted", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_list_cmp_unsorted(_alpm_list_t* left, _alpm_list_t* right, delegate* unmanaged[Cdecl]<void*, void*, int> fn_);

        [DllImport(__DllName, EntryPoint = "alpm_list_diff_sorted", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void alpm_list_diff_sorted(_alpm_list_t* left, _alpm_list_t* right, delegate* unmanaged[Cdecl]<void*, void*, int> fn_, _alpm_list_t** onlyleft, _alpm_list_t** onlyright);

        [DllImport(__DllName, EntryPoint = "alpm_list_diff", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_list_diff(_alpm_list_t* lhs, _alpm_list_t* rhs, delegate* unmanaged[Cdecl]<void*, void*, int> fn_);

        [DllImport(__DllName, EntryPoint = "alpm_list_to_array", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void* alpm_list_to_array(_alpm_list_t* list, nuint n, nuint size);

        /// <summary>
        ///  Determines whether a package filelist contains a given path.
        ///  The provided path should be relative to the install root with no leading
        ///  slashes, e.g. "etc/localtime". When searching for directories, the path must
        ///  have a trailing slash.
        ///  @param filelist a pointer to a package filelist
        ///  @param path the path to search for in the package
        ///  @return a pointer to the matching file or NULL if not found
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_filelist_contains", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_file_t* alpm_filelist_contains(_alpm_filelist_t* filelist, byte* path);

        /// <summary>
        ///  Find group members across a list of databases.
        ///  If a member exists in several databases, only the first database is used.
        ///  IgnorePkg is also handled.
        ///  @param dbs the list of alpm_db_t *
        ///  @param name the name of the group
        ///  @return the list of alpm_pkg_t * (caller is responsible for alpm_list_free)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_find_group_pkgs", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_find_group_pkgs(_alpm_list_t* dbs, byte* name);

        /// <summary>
        ///  Returns the current error code from the handle.
        ///  @param handle the context handle
        ///  @return the current error code of the handle
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_errno", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_errno_t alpm_errno(byte* handle);

        /// <summary>
        ///  Returns the string corresponding to an error number.
        ///  @param err the error code to get the string for
        ///  @return the string relating to the given error code
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_strerror", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_strerror(_alpm_errno_t err);

        /// <summary>
        ///  Initializes the library.
        ///  Creates handle, connects to database and creates lockfile.
        ///  This must be called before any other functions are called.
        ///  @param root the root path for all filesystem operations
        ///  @param dbpath the absolute path to the libalpm database
        ///  @param err an optional variable to hold any error return codes
        ///  @return a context handle on success, NULL on error, err will be set if provided
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_initialize", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_initialize(byte* root, byte* dbpath, _alpm_errno_t* err);

        /// <summary>
        ///  Release the library.
        ///  Disconnects from the database, removes handle and lockfile
        ///  This should be the last alpm call you make.
        ///  After this returns, handle should be considered invalid and cannot be reused
        ///  in any way.
        ///  @param handle the context handle
        ///  @return 0 on success, -1 on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_release", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_release(byte* handle);

        /// <summary>
        ///  Check the PGP signature for the given package file.
        ///  @param pkg the package to check
        ///  @param siglist a pointer to storage for signature results
        ///  @return 0 if valid, -1 if an error occurred or signature is invalid
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_check_pgp_signature", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_pkg_check_pgp_signature(byte* pkg, _alpm_siglist_t* siglist);

        /// <summary>
        ///  Check the PGP signature for the given database.
        ///  @param db the database to check
        ///  @param siglist a pointer to storage for signature results
        ///  @return 0 if valid, -1 if an error occurred or signature is invalid
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_check_pgp_signature", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_db_check_pgp_signature(byte* db, _alpm_siglist_t* siglist);

        /// <summary>
        ///  Clean up and free a signature result list.
        ///  Note that this does not free the siglist object itself in case that
        ///  was allocated on the stack; this is the responsibility of the caller.
        ///  @param siglist a pointer to storage for signature results
        ///  @return 0 on success, -1 on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_siglist_cleanup", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_siglist_cleanup(_alpm_siglist_t* siglist);

        /// <summary>
        ///  Decode a loaded signature in base64 form.
        ///  @param base64_data the signature to attempt to decode
        ///  @param data the decoded data; must be freed by the caller
        ///  @param data_len the length of the returned data
        ///  @return 0 on success, -1 on failure to properly decode
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_decode_signature", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_decode_signature(byte* base64_data, byte** data, nuint* data_len);

        /// <summary>
        ///  Extract the Issuer Key ID from a signature
        ///  @param handle the context handle
        ///  @param identifier the identifier of the key.
        ///  This may be the name of the package or the path to the package.
        ///  @param sig PGP signature
        ///  @param len length of signature
        ///  @param keys a pointer to storage for key IDs
        ///  @return 0 on success, -1 on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_extract_keyid", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_extract_keyid(byte* handle, byte* identifier, byte* sig, nuint len, _alpm_list_t** keys);

        /// <summary>
        ///  Checks dependencies and returns missing ones in a list.
        ///  Dependencies can include versions with depmod operators.
        ///  @param handle the context handle
        ///  @param pkglist the list of local packages
        ///  @param remove an alpm_list_t* of packages to be removed
        ///  @param upgrade an alpm_list_t* of packages to be upgraded (remove-then-upgrade)
        ///  @param reversedeps handles the backward dependencies
        ///  @return an alpm_list_t* of alpm_depmissing_t pointers.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_checkdeps", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_checkdeps(byte* handle, _alpm_list_t* pkglist, _alpm_list_t* remove, _alpm_list_t* upgrade, int reversedeps);

        /// <summary>
        ///  Find a package satisfying a specified dependency.
        ///  The dependency can include versions with depmod operators.
        ///  @param pkgs an alpm_list_t* of alpm_pkg_t where the satisfyer will be searched
        ///  @param depstring package or provision name, versioned or not
        ///  @return a alpm_pkg_t* satisfying depstring
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_find_satisfier", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_find_satisfier(_alpm_list_t* pkgs, byte* depstring);

        /// <summary>
        ///  Find a package satisfying a specified dependency.
        ///  First look for a literal, going through each db one by one. Then look for
        ///  providers. The first satisfyer that belongs to an installed package is
        ///  returned. If no providers belong to an installed package then an
        ///  alpm_question_select_provider_t is created to select the provider.
        ///  The dependency can include versions with depmod operators.
        /// 
        ///  @param handle the context handle
        ///  @param dbs an alpm_list_t* of alpm_db_t where the satisfyer will be searched
        ///  @param depstring package or provision name, versioned or not
        ///  @return a alpm_pkg_t* satisfying depstring
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_find_dbs_satisfier", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_find_dbs_satisfier(byte* handle, _alpm_list_t* dbs, byte* depstring);

        /// <summary>
        ///  Check the package conflicts in a database
        /// 
        ///  @param handle the context handle
        ///  @param pkglist the list of packages to check
        /// 
        ///  @return an alpm_list_t of alpm_conflict_t
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_checkconflicts", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_checkconflicts(byte* handle, _alpm_list_t* pkglist);

        /// <summary>
        ///  Returns a newly allocated string representing the dependency information.
        ///  @param dep a dependency info structure
        ///  @return a formatted string, e.g. "glibc&gt;=2.12"
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_dep_compute_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_dep_compute_string(_alpm_depend_t* dep);

        /// <summary>
        ///  Return a newly allocated dependency information parsed from a string
        /// \link alpm_dep_free should be used to free the dependency \endlink
        ///  @param depstring a formatted string, e.g. "glibc=2.12"
        ///  @return a dependency info structure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_dep_from_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_depend_t* alpm_dep_from_string(byte* depstring);

        /// <summary>
        ///  Free a dependency info structure
        ///  @param dep struct to free
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_dep_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void alpm_dep_free(_alpm_depend_t* dep);

        /// <summary>
        ///  Free a fileconflict and its members.
        ///  @param conflict the fileconflict to free
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_fileconflict_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void alpm_fileconflict_free(_alpm_fileconflict_t* conflict);

        /// <summary>
        ///  Free a depmissing and its members
        ///  @param miss the depmissing to free
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_depmissing_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void alpm_depmissing_free(_alpm_depmissing_t* miss);

        /// <summary>
        ///  Free a conflict and its members.
        ///  @param conflict the conflict to free
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_conflict_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void alpm_conflict_free(_alpm_conflict_t* conflict);

        /// <summary>
        ///  Get the database of locally installed packages.
        ///  The returned pointer points to an internal structure
        ///  of libalpm which should only be manipulated through
        ///  libalpm functions.
        ///  @return a reference to the local database
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_get_localdb", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_get_localdb(byte* handle);

        /// <summary>
        ///  Get the list of sync databases.
        ///  Returns a list of alpm_db_t structures, one for each registered
        ///  sync database.
        /// 
        ///  @param handle the context handle
        ///  @return a reference to an internal list of alpm_db_t structures
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_get_syncdbs", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_get_syncdbs(byte* handle);

        /// <summary>
        ///  Register a sync database of packages.
        ///  Databases can not be registered when there is an active transaction.
        /// 
        ///  @param handle the context handle
        ///  @param treename the name of the sync repository
        ///  @param level what level of signature checking to perform on the
        ///  database; note that this must be a '.sig' file type verification
        ///  @return an alpm_db_t* on success (the value), NULL on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_register_syncdb", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_register_syncdb(byte* handle, byte* treename, int level);

        /// <summary>
        ///  Unregister all package databases.
        ///  Databases can not be unregistered while there is an active transaction.
        /// 
        ///  @param handle the context handle
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_unregister_all_syncdbs", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_unregister_all_syncdbs(byte* handle);

        /// <summary>
        ///  Unregister a package database.
        ///  Databases can not be unregistered when there is an active transaction.
        /// 
        ///  @param db pointer to the package database to unregister
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_unregister", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_db_unregister(byte* db);

        /// <summary>
        ///  Get the handle of a package database.
        ///  @param db pointer to the package database
        ///  @return the alpm handle that the package database belongs to
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_get_handle", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_db_get_handle(byte* db);

        /// <summary>
        ///  Get the name of a package database.
        ///  @param db pointer to the package database
        ///  @return the name of the package database, NULL on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_get_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_db_get_name(byte* db);

        /// <summary>
        ///  Get the signature verification level for a database.
        ///  Will return the default verification level if this database is set up
        ///  with ALPM_SIG_USE_DEFAULT.
        ///  @param db pointer to the package database
        ///  @return the signature verification level
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_get_siglevel", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_db_get_siglevel(byte* db);

        /// <summary>
        ///  Check the validity of a database.
        ///  This is most useful for sync databases and verifying signature status.
        ///  If invalid, the handle error code will be set accordingly.
        ///  @param db pointer to the package database
        ///  @return 0 if valid, -1 if invalid (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_get_valid", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_db_get_valid(byte* db);

        /// <summary>
        ///  Get the list of servers assigned to this db.
        ///  @param db pointer to the database to get the servers from
        ///  @return a char* list of servers
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_get_servers", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_db_get_servers(byte* db);

        /// <summary>
        ///  Sets the list of servers for the database to use.
        ///  @param db the database to set the servers. The list will be duped and
        ///  the original will still need to be freed by the caller.
        ///  @param servers a char* list of servers.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_set_servers", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_db_set_servers(byte* db, _alpm_list_t* servers);

        /// <summary>
        ///  Add a download server to a database.
        ///  @param db database pointer
        ///  @param url url of the server
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_add_server", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_db_add_server(byte* db, byte* url);

        /// <summary>
        ///  Remove a download server from a database.
        ///  @param db database pointer
        ///  @param url url of the server
        ///  @return 0 on success, 1 on server not present,
        ///  -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_remove_server", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_db_remove_server(byte* db, byte* url);

        /// <summary>
        ///  Get the list of cache servers assigned to this db.
        ///  @param db pointer to the database to get the servers from
        ///  @return a char* list of servers
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_get_cache_servers", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_db_get_cache_servers(byte* db);

        /// <summary>
        ///  Sets the list of cache servers for the database to use.
        ///  @param db the database to set the servers. The list will be duped and
        ///  the original will still need to be freed by the caller.
        ///  @param servers a char* list of servers.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_set_cache_servers", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_db_set_cache_servers(byte* db, _alpm_list_t* servers);

        /// <summary>
        ///  Add a download cache server to a database.
        ///  @param db database pointer
        ///  @param url url of the server
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_add_cache_server", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_db_add_cache_server(byte* db, byte* url);

        /// <summary>
        ///  Remove a download cache server from a database.
        ///  @param db database pointer
        ///  @param url url of the server
        ///  @return 0 on success, 1 on server not present,
        ///  -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_remove_cache_server", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_db_remove_cache_server(byte* db, byte* url);

        /// <summary>
        ///  Update package databases.
        /// 
        ///  An update of the package databases in the list \a dbs will be attempted.
        ///  Unless \a force is true, the update will only be performed if the remote
        ///  databases were modified since the last update.
        /// 
        ///  This operation requires a database lock, and will return an applicable error
        ///  if the lock could not be obtained.
        /// 
        ///  Example:
        ///  @code
        ///  alpm_list_t *dbs = alpm_get_syncdbs(config-&gt;handle);
        ///  ret = alpm_db_update(config-&gt;handle, dbs, force);
        ///  if(ret &lt; 0) {
        ///      pm_printf(ALPM_LOG_ERROR, _("failed to synchronize all databases (%s)\n"),
        ///          alpm_strerror(alpm_errno(config-&gt;handle)));
        ///  }
        ///  @endcode
        /// 
        ///  @note After a successful update, the \link alpm_db_get_pkgcache()
        ///  package cache \endlink will be invalidated
        ///  @param handle the context handle
        ///  @param dbs list of package databases to update
        ///  @param force if true, then forces the update, otherwise update only in case
        ///  the databases aren't up to date
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly),
        ///  1 if all databases are up to to date
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_update", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_db_update(byte* handle, _alpm_list_t* dbs, int force);

        /// <summary>
        ///  Get a package entry from a package database.
        ///  Looking up a package is O(1) and will be significantly faster than
        ///  iterating over the pkgcahe.
        ///  @param db pointer to the package database to get the package from
        ///  @param name of the package
        ///  @return the package entry on success, NULL on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_get_pkg", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_db_get_pkg(byte* db, byte* name);

        /// <summary>
        ///  Get the package cache of a package database.
        ///  This is a list of all packages the db contains.
        ///  @param db pointer to the package database to get the package from
        ///  @return the list of packages on success, NULL on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_get_pkgcache", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_db_get_pkgcache(byte* db);

        /// <summary>
        ///  Get a group entry from a package database.
        ///  Looking up a group is O(1) and will be significantly faster than
        ///  iterating over the groupcahe.
        ///  @param db pointer to the package database to get the group from
        ///  @param name of the group
        ///  @return the groups entry on success, NULL on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_get_group", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_group_t* alpm_db_get_group(byte* db, byte* name);

        /// <summary>
        ///  Get the group cache of a package database.
        ///  @param db pointer to the package database to get the group from
        ///  @return the list of groups on success, NULL on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_get_groupcache", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_db_get_groupcache(byte* db);

        /// <summary>
        ///  Searches a database with regular expressions.
        ///  @param db pointer to the package database to search in
        ///  @param needles a list of regular expressions to search for
        ///  @param ret pointer to list for storing packages matching all
        ///  regular expressions - must point to an empty (NULL) alpm_list_t *.
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_search", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_db_search(byte* db, _alpm_list_t* needles, _alpm_list_t** ret);

        /// <summary>
        ///  Sets the usage of a database.
        ///  @param db pointer to the package database to set the status for
        ///  @param usage a bitmask of alpm_db_usage_t values
        ///  @return 0 on success, or -1 on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_set_usage", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_db_set_usage(byte* db, int usage);

        /// <summary>
        ///  Gets the usage of a database.
        ///  @param db pointer to the package database to get the status of
        ///  @param usage pointer to an alpm_db_usage_t to store db's status
        ///  @return 0 on success, or -1 on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_db_get_usage", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_db_get_usage(byte* db, int* usage);

        /// <summary>
        ///  A printf-like function for logging.
        ///  @param handle the context handle
        ///  @param prefix caller-specific prefix for the log
        ///  @param fmt output format
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_logaction", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_logaction(byte* handle, byte* prefix, byte* fmt);

        /// <summary>
        ///  Returns the callback used for logging.
        ///  @param handle the context handle
        ///  @return the currently set log callback
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_logcb", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern delegate* unmanaged[Cdecl]<void*, _alpm_loglevel_t, byte*, __va_list_tag*, void> alpm_option_get_logcb(byte* handle);

        /// <summary>
        ///  Returns the callback used for logging.
        ///  @param handle the context handle
        ///  @return the currently set log callback context
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_logcb_ctx", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void* alpm_option_get_logcb_ctx(byte* handle);

        /// <summary>
        ///  Sets the callback used for logging.
        ///  @param handle the context handle
        ///  @param cb the cb to use
        ///  @param ctx user-provided context to pass to cb
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_logcb", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_logcb(byte* handle, delegate* unmanaged[Cdecl]<void*, _alpm_loglevel_t, byte*, __va_list_tag*, void> cb, void* ctx);

        /// <summary>
        ///  Returns the callback used to report download progress.
        ///  @param handle the context handle
        ///  @return the currently set download callback
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_dlcb", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern delegate* unmanaged[Cdecl]<void*, byte*, _alpm_download_event_type_t, void*, void> alpm_option_get_dlcb(byte* handle);

        /// <summary>
        ///  Returns the callback used to report download progress.
        ///  @param handle the context handle
        ///  @return the currently set download callback context
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_dlcb_ctx", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void* alpm_option_get_dlcb_ctx(byte* handle);

        /// <summary>
        ///  Sets the callback used to report download progress.
        ///  @param handle the context handle
        ///  @param cb the cb to use
        ///  @param ctx user-provided context to pass to cb
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_dlcb", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_dlcb(byte* handle, delegate* unmanaged[Cdecl]<void*, byte*, _alpm_download_event_type_t, void*, void> cb, void* ctx);

        /// <summary>
        ///  Returns the downloading callback.
        ///  @param handle the context handle
        ///  @return the currently set fetch callback
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_fetchcb", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern delegate* unmanaged[Cdecl]<void*, byte*, byte*, int, int> alpm_option_get_fetchcb(byte* handle);

        /// <summary>
        ///  Returns the downloading callback.
        ///  @param handle the context handle
        ///  @return the currently set fetch callback context
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_fetchcb_ctx", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void* alpm_option_get_fetchcb_ctx(byte* handle);

        /// <summary>
        ///  Sets the downloading callback.
        ///  @param handle the context handle
        ///  @param cb the cb to use
        ///  @param ctx user-provided context to pass to cb
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_fetchcb", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_fetchcb(byte* handle, delegate* unmanaged[Cdecl]<void*, byte*, byte*, int, int> cb, void* ctx);

        /// <summary>
        ///  Returns the callback used for events.
        ///  @param handle the context handle
        ///  @return the currently set event callback
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_eventcb", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern delegate* unmanaged[Cdecl]<void*, _alpm_event_t*, void> alpm_option_get_eventcb(byte* handle);

        /// <summary>
        ///  Returns the callback used for events.
        ///  @param handle the context handle
        ///  @return the currently set event callback context
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_eventcb_ctx", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void* alpm_option_get_eventcb_ctx(byte* handle);

        /// <summary>
        ///  Sets the callback used for events.
        ///  @param handle the context handle
        ///  @param cb the cb to use
        ///  @param ctx user-provided context to pass to cb
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_eventcb", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_eventcb(byte* handle, delegate* unmanaged[Cdecl]<void*, _alpm_event_t*, void> cb, void* ctx);

        /// <summary>
        ///  Returns the callback used for questions.
        ///  @param handle the context handle
        ///  @return the currently set question callback
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_questioncb", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern delegate* unmanaged[Cdecl]<void*, _alpm_question_t*, void> alpm_option_get_questioncb(byte* handle);

        /// <summary>
        ///  Returns the callback used for questions.
        ///  @param handle the context handle
        ///  @return the currently set question callback context
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_questioncb_ctx", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void* alpm_option_get_questioncb_ctx(byte* handle);

        /// <summary>
        ///  Sets the callback used for questions.
        ///  @param handle the context handle
        ///  @param cb the cb to use
        ///  @param ctx user-provided context to pass to cb
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_questioncb", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_questioncb(byte* handle, delegate* unmanaged[Cdecl]<void*, _alpm_question_t*, void> cb, void* ctx);

        /// <summary>
        /// Returns the callback used for operation progress.
        ///  @param handle the context handle
        ///  @return the currently set progress callback
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_progresscb", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern delegate* unmanaged[Cdecl]<void*, _alpm_progress_t, byte*, int, nuint, nuint, void> alpm_option_get_progresscb(byte* handle);

        /// <summary>
        /// Returns the callback used for operation progress.
        ///  @param handle the context handle
        ///  @return the currently set progress callback context
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_progresscb_ctx", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void* alpm_option_get_progresscb_ctx(byte* handle);

        /// <summary>
        ///  Sets the callback used for operation progress.
        ///  @param handle the context handle
        ///  @param cb the cb to use
        ///  @param ctx user-provided context to pass to cb
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_progresscb", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_progresscb(byte* handle, delegate* unmanaged[Cdecl]<void*, _alpm_progress_t, byte*, int, nuint, nuint, void> cb, void* ctx);

        /// <summary>
        ///  Returns the root path. Read-only.
        ///  @param handle the context handle
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_root", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_option_get_root(byte* handle);

        /// <summary>
        ///  Returns the path to the database directory. Read-only.
        ///  @param handle the context handle
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_dbpath", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_option_get_dbpath(byte* handle);

        /// <summary>
        ///  Get the name of the database lock file. Read-only.
        ///  This is the name that the lockfile would have. It does not
        ///  matter if the lockfile actually exists on disk.
        ///  @param handle the context handle
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_lockfile", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_option_get_lockfile(byte* handle);

        /// <summary>
        ///  Gets the currently configured cachedirs,
        ///  @param handle the context handle
        ///  @return a char* list of cache directories
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_cachedirs", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_option_get_cachedirs(byte* handle);

        /// <summary>
        ///  Sets the cachedirs.
        ///  @param handle the context handle
        ///  @param cachedirs a char* list of cachdirs. The list will be duped and
        ///  the original will still need to be freed by the caller.
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_cachedirs", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_cachedirs(byte* handle, _alpm_list_t* cachedirs);

        /// <summary>
        ///  Append a cachedir to the configured cachedirs.
        ///  @param handle the context handle
        ///  @param cachedir the cachedir to add
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_add_cachedir", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_add_cachedir(byte* handle, byte* cachedir);

        /// <summary>
        ///  Remove a cachedir from the configured cachedirs.
        ///  @param handle the context handle
        ///  @param cachedir the cachedir to remove
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_remove_cachedir", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_remove_cachedir(byte* handle, byte* cachedir);

        /// <summary>
        ///  Gets the currently configured hookdirs,
        ///  @param handle the context handle
        ///  @return a char* list of hook directories
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_hookdirs", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_option_get_hookdirs(byte* handle);

        /// <summary>
        ///  Sets the hookdirs.
        ///  @param handle the context handle
        ///  @param hookdirs a char* list of hookdirs. The list will be duped and
        ///  the original will still need to be freed by the caller.
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_hookdirs", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_hookdirs(byte* handle, _alpm_list_t* hookdirs);

        /// <summary>
        ///  Append a hookdir to the configured hookdirs.
        ///  @param handle the context handle
        ///  @param hookdir the hookdir to add
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_add_hookdir", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_add_hookdir(byte* handle, byte* hookdir);

        /// <summary>
        ///  Remove a hookdir from the configured hookdirs.
        ///  @param handle the context handle
        ///  @param hookdir the hookdir to remove
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_remove_hookdir", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_remove_hookdir(byte* handle, byte* hookdir);

        /// <summary>
        ///  Gets the currently configured overwritable files,
        ///  @param handle the context handle
        ///  @return a char* list of overwritable file globs
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_overwrite_files", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_option_get_overwrite_files(byte* handle);

        /// <summary>
        ///  Sets the overwritable files.
        ///  @param handle the context handle
        ///  @param globs a char* list of overwritable file globs. The list will be duped and
        ///  the original will still need to be freed by the caller.
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_overwrite_files", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_overwrite_files(byte* handle, _alpm_list_t* globs);

        /// <summary>
        ///  Append an overwritable file to the configured overwritable files.
        ///  @param handle the context handle
        ///  @param glob the file glob to add
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_add_overwrite_file", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_add_overwrite_file(byte* handle, byte* glob);

        /// <summary>
        ///  Remove a file glob from the configured overwritable files globs.
        ///  @note The overwritable file list contains a list of globs. The glob to
        ///  remove must exactly match the entry to remove. There is no glob expansion.
        ///  @param handle the context handle
        ///  @param glob the file glob to remove
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_remove_overwrite_file", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_remove_overwrite_file(byte* handle, byte* glob);

        /// <summary>
        ///  Gets the filepath to the currently set logfile.
        ///  @param handle the context handle
        ///  @return the path to the logfile
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_logfile", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_option_get_logfile(byte* handle);

        /// <summary>
        ///  Sets the logfile path.
        ///  @param handle the context handle
        ///  @param logfile path to the new location of the logfile
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_logfile", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_logfile(byte* handle, byte* logfile);

        /// <summary>
        ///  Returns the path to libalpm's GnuPG home directory.
        ///  @param handle the context handle
        ///  @return the path to libalpms's GnuPG home directory
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_gpgdir", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_option_get_gpgdir(byte* handle);

        /// <summary>
        ///  Sets the path to libalpm's GnuPG home directory.
        ///  @param handle the context handle
        ///  @param gpgdir the gpgdir to set
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_gpgdir", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_gpgdir(byte* handle, byte* gpgdir);

        /// <summary>
        ///  Returns the user to switch to for sensitive operations.
        ///  @return the user name
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_sandboxuser", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_option_get_sandboxuser(byte* handle);

        /// <summary>
        ///  Sets the user to switch to for sensitive operations.
        ///  @param handle the context handle
        ///  @param sandboxuser the user to set
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_sandboxuser", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_sandboxuser(byte* handle, byte* sandboxuser);

        /// <summary>
        ///  Returns whether to use syslog (0 is FALSE, TRUE otherwise).
        ///  @param handle the context handle
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_usesyslog", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_get_usesyslog(byte* handle);

        /// <summary>
        ///  Sets whether to use syslog (0 is FALSE, TRUE otherwise).
        ///  @param handle the context handle
        ///  @param usesyslog whether to use the syslog (0 is FALSE, TRUE otherwise)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_usesyslog", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_usesyslog(byte* handle, int usesyslog);

        /// <summary>
        ///  Get the list of no-upgrade files
        ///  @param handle the context handle
        ///  @return the char* list of no-upgrade files
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_noupgrades", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_option_get_noupgrades(byte* handle);

        /// <summary>
        ///  Add a file to the no-upgrade list
        ///  @param handle the context handle
        ///  @param path the path to add
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_add_noupgrade", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_add_noupgrade(byte* handle, byte* path);

        /// <summary>
        ///  Sets the list of no-upgrade files
        ///  @param handle the context handle
        ///  @param noupgrade a char* list of file to not upgrade.
        ///  The list will be duped and the original will still need to be freed by the caller.
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_noupgrades", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_noupgrades(byte* handle, _alpm_list_t* noupgrade);

        /// <summary>
        ///  Remove an entry from the no-upgrade list
        ///  @param handle the context handle
        ///  @param path the path to remove
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_remove_noupgrade", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_remove_noupgrade(byte* handle, byte* path);

        /// <summary>
        ///  Test if a path matches any of the globs in the no-upgrade list
        ///  @param handle the context handle
        ///  @param path the path to test
        ///  @return 0 is the path matches a glob, negative if there is no match and
        ///  positive is the  match was inverted
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_match_noupgrade", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_match_noupgrade(byte* handle, byte* path);

        /// <summary>
        ///  Get the list of no-extract files
        ///  @param handle the context handle
        ///  @return the char* list of no-extract files
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_noextracts", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_option_get_noextracts(byte* handle);

        /// <summary>
        ///  Add a file to the no-extract list
        ///  @param handle the context handle
        ///  @param path the path to add
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_add_noextract", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_add_noextract(byte* handle, byte* path);

        /// <summary>
        ///  Sets the list of no-extract files
        ///  @param handle the context handle
        ///  @param noextract a char* list of file to not extract.
        ///  The list will be duped and the original will still need to be freed by the caller.
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_noextracts", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_noextracts(byte* handle, _alpm_list_t* noextract);

        /// <summary>
        ///  Remove an entry from the no-extract list
        ///  @param handle the context handle
        ///  @param path the path to remove
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_remove_noextract", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_remove_noextract(byte* handle, byte* path);

        /// <summary>
        ///  Test if a path matches any of the globs in the no-extract list
        ///  @param handle the context handle
        ///  @param path the path to test
        ///  @return 0 is the path matches a glob, negative if there is no match and
        ///  positive is the  match was inverted
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_match_noextract", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_match_noextract(byte* handle, byte* path);

        /// <summary>
        ///  Get the list of ignored packages
        ///  @param handle the context handle
        ///  @return the char* list of ignored packages
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_ignorepkgs", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_option_get_ignorepkgs(byte* handle);

        /// <summary>
        ///  Add a file to the ignored package list
        ///  @param handle the context handle
        ///  @param pkg the package to add
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_add_ignorepkg", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_add_ignorepkg(byte* handle, byte* pkg);

        /// <summary>
        ///  Sets the list of packages to ignore
        ///  @param handle the context handle
        ///  @param ignorepkgs a char* list of packages to ignore
        ///  The list will be duped and the original will still need to be freed by the caller.
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_ignorepkgs", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_ignorepkgs(byte* handle, _alpm_list_t* ignorepkgs);

        /// <summary>
        ///  Remove an entry from the ignorepkg list
        ///  @param handle the context handle
        ///  @param pkg the package to remove
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_remove_ignorepkg", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_remove_ignorepkg(byte* handle, byte* pkg);

        /// <summary>
        ///  Get the list of ignored groups
        ///  @param handle the context handle
        ///  @return the char* list of ignored groups
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_ignoregroups", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_option_get_ignoregroups(byte* handle);

        /// <summary>
        ///  Add a file to the ignored group list
        ///  @param handle the context handle
        ///  @param grp the group to add
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_add_ignoregroup", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_add_ignoregroup(byte* handle, byte* grp);

        /// <summary>
        ///  Sets the list of groups to ignore
        ///  @param handle the context handle
        ///  @param ignoregrps a char* list of groups to ignore
        ///  The list will be duped and the original will still need to be freed by the caller.
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_ignoregroups", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_ignoregroups(byte* handle, _alpm_list_t* ignoregrps);

        /// <summary>
        ///  Remove an entry from the ignoregroup list
        ///  @param handle the context handle
        ///  @param grp the group to remove
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_remove_ignoregroup", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_remove_ignoregroup(byte* handle, byte* grp);

        /// <summary>
        ///  Gets the list of dependencies that are assumed to be met
        ///  @param handle the context handle
        ///  @return a list of alpm_depend_t*
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_assumeinstalled", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_option_get_assumeinstalled(byte* handle);

        /// <summary>
        ///  Add a depend to the assumed installed list
        ///  @param handle the context handle
        ///  @param dep the dependency to add
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_add_assumeinstalled", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_add_assumeinstalled(byte* handle, _alpm_depend_t* dep);

        /// <summary>
        ///  Sets the list of dependencies that are assumed to be met
        ///  @param handle the context handle
        ///  @param deps a list of *alpm_depend_t
        ///  The list will be duped and the original will still need to be freed by the caller.
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_assumeinstalled", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_assumeinstalled(byte* handle, _alpm_list_t* deps);

        /// <summary>
        ///  Remove an entry from the assume installed list
        ///  @param handle the context handle
        ///  @param dep the dep to remove
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_remove_assumeinstalled", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_remove_assumeinstalled(byte* handle, _alpm_depend_t* dep);

        /// <summary>
        ///  Returns the allowed physical architectures.
        ///  @param handle the context handle
        ///  @return the list of physical architectures (caller is responsible for alpm_list_free)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_physical_architectures", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_option_get_physical_architectures(byte* handle);

        /// <summary>
        ///  Returns the allowed package architecture.
        ///  @param handle the context handle
        ///  @return the configured package architectures
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_architectures", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_option_get_architectures(byte* handle);

        /// <summary>
        ///  Adds an allowed package architecture.
        ///  @param handle the context handle
        ///  @param arch the architecture to set
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_add_architecture", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_add_architecture(byte* handle, byte* arch);

        /// <summary>
        ///  Sets the allowed package architecture.
        ///  @param handle the context handle
        ///  @param arches the architecture to set
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_architectures", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_architectures(byte* handle, _alpm_list_t* arches);

        /// <summary>
        ///  Removes an allowed package architecture.
        ///  @param handle the context handle
        ///  @param arch the architecture to remove
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_remove_architecture", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_remove_architecture(byte* handle, byte* arch);

        /// <summary>
        ///  Get whether or not checking for free space before installing packages is enabled.
        ///  @param handle the context handle
        ///  @return 0 if disabled, 1 if enabled
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_checkspace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_get_checkspace(byte* handle);

        /// <summary>
        ///  Enable/disable checking free space before installing packages.
        ///  @param handle the context handle
        ///  @param checkspace 0 for disabled, 1 for enabled
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_checkspace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_checkspace(byte* handle, int checkspace);

        /// <summary>
        ///  Gets the configured database extension.
        ///  @param handle the context handle
        ///  @return the configured database extension
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_dbext", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_option_get_dbext(byte* handle);

        /// <summary>
        ///  Sets the database extension.
        ///  @param handle the context handle
        ///  @param dbext the database extension to use
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_dbext", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_dbext(byte* handle, byte* dbext);

        /// <summary>
        ///  Get the default siglevel.
        ///  @param handle the context handle
        ///  @return a \link alpm_siglevel_t \endlink bitfield of the siglevel
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_default_siglevel", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_get_default_siglevel(byte* handle);

        /// <summary>
        ///  Set the default siglevel.
        ///  @param handle the context handle
        ///  @param level a \link alpm_siglevel_t \endlink bitfield of the level to set
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_default_siglevel", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_default_siglevel(byte* handle, int level);

        /// <summary>
        ///  Get the configured local file siglevel.
        ///  @param handle the context handle
        ///  @return a \link alpm_siglevel_t \endlink bitfield of the siglevel
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_local_file_siglevel", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_get_local_file_siglevel(byte* handle);

        /// <summary>
        ///  Set the local file siglevel.
        ///  @param handle the context handle
        ///  @param level a \link alpm_siglevel_t \endlink bitfield of the level to set
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_local_file_siglevel", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_local_file_siglevel(byte* handle, int level);

        /// <summary>
        ///  Get the configured remote file siglevel.
        ///  @param handle the context handle
        ///  @return a \link alpm_siglevel_t \endlink bitfield of the siglevel
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_remote_file_siglevel", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_get_remote_file_siglevel(byte* handle);

        /// <summary>
        ///  Set the remote file siglevel.
        ///  @param handle the context handle
        ///  @param level a \link alpm_siglevel_t \endlink bitfield of the level to set
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_remote_file_siglevel", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_remote_file_siglevel(byte* handle, int level);

        /// <summary>
        ///  Enables/disables the download timeout.
        ///  @param handle the context handle
        ///  @param disable_dl_timeout 0 for enabled, 1 for disabled
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_disable_dl_timeout", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_disable_dl_timeout(byte* handle, ushort disable_dl_timeout);

        /// <summary>
        ///  Gets the number of parallel streams to download database and package files.
        ///  @param handle the context handle
        ///  @return the number of parallel streams to download database and package files
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_get_parallel_downloads", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_get_parallel_downloads(byte* handle);

        /// <summary>
        ///  Sets number of parallel streams to download database and package files.
        ///  @param handle the context handle
        ///  @param num_streams number of parallel download streams
        ///  @return 0 on success, -1 on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_parallel_downloads", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_parallel_downloads(byte* handle, uint num_streams);

        /// <summary>
        ///  Enables/disables the sandbox.
        ///  @param handle the context handle
        ///  @param disable_sandbox 0 for enabled, 1 for disabled
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_option_set_disable_sandbox", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_option_set_disable_sandbox(byte* handle, ushort disable_sandbox);

        /// <summary>
        ///  Create a package from a file.
        ///  If full is false, the archive is read only until all necessary
        ///  metadata is found. If it is true, the entire archive is read, which
        ///  serves as a verification of integrity and the filelist can be created.
        ///  The allocated structure should be freed using alpm_pkg_free().
        ///  @param handle the context handle
        ///  @param filename location of the package tarball
        ///  @param full whether to stop the load after metadata is read or continue
        ///  through the full archive
        ///  @param level what level of package signature checking to perform on the
        ///  package; note that this must be a '.sig' file type verification
        ///  @param pkg address of the package pointer
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_load", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_pkg_load(byte* handle, byte* filename, int full, int level, byte** pkg);

        /// <summary>
        ///  Fetch a list of remote packages.
        ///  @param handle the context handle
        ///  @param urls list of package URLs to download
        ///  @param fetched list of filepaths to the fetched packages, each item
        ///     corresponds to one in `urls` list. This is an output parameter,
        ///     the caller should provide a pointer to an empty list
        ///     (*fetched === NULL) and the callee fills the list with data.
        ///  @return 0 on success or -1 on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_fetch_pkgurl", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_fetch_pkgurl(byte* handle, _alpm_list_t* urls, _alpm_list_t** fetched);

        /// <summary>
        ///  Find a package in a list by name.
        ///  @param haystack a list of alpm_pkg_t
        ///  @param needle the package name
        ///  @return a pointer to the package if found or NULL
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_find", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_pkg_find(_alpm_list_t* haystack, byte* needle);

        /// <summary>
        ///  Free a package.
        ///  Only packages loaded with \link alpm_pkg_load \endlink can be freed.
        ///  Packages from databases will be freed by libalpm when they are unregistered.
        ///  @param pkg package pointer to free
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_pkg_free(byte* pkg);

        /// <summary>
        ///  Check the integrity (with md5) of a package from the sync cache.
        ///  @param pkg package pointer
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_checkmd5sum", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_pkg_checkmd5sum(byte* pkg);

        /// <summary>
        ///  Compare two version strings and determine which one is 'newer'.
        ///  Returns a value comparable to the way strcmp works. Returns 1
        ///  if a is newer than b, 0 if a and b are the same version, or -1
        ///  if b is newer than a.
        /// 
        ///  Different epoch values for version strings will override any further
        ///  comparison. If no epoch is provided, 0 is assumed.
        /// 
        ///  Keep in mind that the pkgrel is only compared if it is available
        ///  on both versions handed to this function. For example, comparing
        ///  1.5-1 and 1.5 will yield 0; comparing 1.5-1 and 1.5-2 will yield
        ///  -1 as expected. This is mainly for supporting versioned dependencies
        ///  that do not include the pkgrel.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_vercmp", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_pkg_vercmp(byte* a, byte* b);

        /// <summary>
        ///  Computes the list of packages requiring a given package.
        ///  The return value of this function is a newly allocated
        ///  list of package names (char*), it should be freed by the caller.
        ///  @param pkg a package
        ///  @return the list of packages requiring pkg
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_compute_requiredby", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_pkg_compute_requiredby(byte* pkg);

        /// <summary>
        ///  Computes the list of packages optionally requiring a given package.
        ///  The return value of this function is a newly allocated
        ///  list of package names (char*), it should be freed by the caller.
        ///  @param pkg a package
        ///  @return the list of packages optionally requiring pkg
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_compute_optionalfor", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_pkg_compute_optionalfor(byte* pkg);

        /// <summary>
        ///  Test if a package should be ignored.
        ///  Checks if the package is ignored via IgnorePkg, or if the package is
        ///  in a group ignored via IgnoreGroup.
        ///  @param handle the context handle
        ///  @param pkg the package to test
        ///  @return 1 if the package should be ignored, 0 otherwise
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_should_ignore", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_pkg_should_ignore(byte* handle, byte* pkg);

        /// <summary>
        ///  Gets the handle of a package
        ///  @param pkg a pointer to package
        ///  @return the alpm handle that the package belongs to
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_handle", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_pkg_get_handle(byte* pkg);

        /// <summary>
        ///  Gets the name of the file from which the package was loaded.
        ///  @param pkg a pointer to package
        ///  @return a reference to an internal string
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_filename", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_pkg_get_filename(byte* pkg);

        /// <summary>
        ///  Returns the package base name.
        ///  @param pkg a pointer to package
        ///  @return a reference to an internal string
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_base", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_pkg_get_base(byte* pkg);

        /// <summary>
        ///  Returns the package name.
        ///  @param pkg a pointer to package
        ///  @return a reference to an internal string
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_pkg_get_name(byte* pkg);

        /// <summary>
        ///  Returns the package version as a string.
        ///  This includes all available epoch, version, and pkgrel components. Use
        ///  alpm_pkg_vercmp() to compare version strings if necessary.
        ///  @param pkg a pointer to package
        ///  @return a reference to an internal string
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_version", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_pkg_get_version(byte* pkg);

        /// <summary>
        ///  Returns the origin of the package.
        ///  @return an alpm_pkgfrom_t constant, -1 on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_origin", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_pkgfrom_t alpm_pkg_get_origin(byte* pkg);

        /// <summary>
        ///  Returns the installed db of the package.
        ///  @return an alpm_pkgfrom_t constant, -1 on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_installed_db", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_pkg_get_installed_db(byte* pkg);

        /// <summary>
        ///  Returns the package description.
        ///  @param pkg a pointer to package
        ///  @return a reference to an internal string
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_desc", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_pkg_get_desc(byte* pkg);

        /// <summary>
        ///  Returns the package URL.
        ///  @param pkg a pointer to package
        ///  @return a reference to an internal string
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_url", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_pkg_get_url(byte* pkg);

        /// <summary>
        ///  Returns the build timestamp of the package.
        ///  @param pkg a pointer to package
        ///  @return the timestamp of the build time
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_builddate", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern long alpm_pkg_get_builddate(byte* pkg);

        /// <summary>
        ///  Returns the install timestamp of the package.
        ///  @param pkg a pointer to package
        ///  @return the timestamp of the install time
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_installdate", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern long alpm_pkg_get_installdate(byte* pkg);

        /// <summary>
        ///  Returns the packager's name.
        ///  @param pkg a pointer to package
        ///  @return a reference to an internal string
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_packager", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_pkg_get_packager(byte* pkg);

        /// <summary>
        ///  Returns the package's MD5 checksum as a string.
        ///  The returned string is a sequence of 32 lowercase hexadecimal digits.
        ///  @param pkg a pointer to package
        ///  @return a reference to an internal string
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_md5sum", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_pkg_get_md5sum(byte* pkg);

        /// <summary>
        ///  Returns the package's SHA256 checksum as a string.
        ///  The returned string is a sequence of 64 lowercase hexadecimal digits.
        ///  @param pkg a pointer to package
        ///  @return a reference to an internal string
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_sha256sum", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_pkg_get_sha256sum(byte* pkg);

        /// <summary>
        ///  Returns the architecture for which the package was built.
        ///  @param pkg a pointer to package
        ///  @return a reference to an internal string
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_arch", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_pkg_get_arch(byte* pkg);

        /// <summary>
        ///  Returns the size of the package. This is only available for sync database
        ///  packages and package files, not those loaded from the local database.
        ///  @param pkg a pointer to package
        ///  @return the size of the package in bytes.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern CLong alpm_pkg_get_size(byte* pkg);

        /// <summary>
        ///  Returns the installed size of the package.
        ///  @param pkg a pointer to package
        ///  @return the total size of files installed by the package.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_isize", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern CLong alpm_pkg_get_isize(byte* pkg);

        /// <summary>
        ///  Returns the package installation reason.
        ///  @param pkg a pointer to package
        ///  @return an enum member giving the install reason.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_reason", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_pkgreason_t alpm_pkg_get_reason(byte* pkg);

        /// <summary>
        ///  Returns the list of package licenses.
        ///  @param pkg a pointer to package
        ///  @return a pointer to an internal list of strings.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_licenses", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_pkg_get_licenses(byte* pkg);

        /// <summary>
        ///  Returns the list of package groups.
        ///  @param pkg a pointer to package
        ///  @return a pointer to an internal list of strings.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_groups", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_pkg_get_groups(byte* pkg);

        /// <summary>
        ///  Returns the list of package dependencies as alpm_depend_t.
        ///  @param pkg a pointer to package
        ///  @return a reference to an internal list of alpm_depend_t structures.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_depends", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_pkg_get_depends(byte* pkg);

        /// <summary>
        ///  Returns the list of package optional dependencies.
        ///  @param pkg a pointer to package
        ///  @return a reference to an internal list of alpm_depend_t structures.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_optdepends", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_pkg_get_optdepends(byte* pkg);

        /// <summary>
        ///  Returns a list of package check dependencies
        ///  @param pkg a pointer to package
        ///  @return a reference to an internal list of alpm_depend_t structures.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_checkdepends", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_pkg_get_checkdepends(byte* pkg);

        /// <summary>
        ///  Returns a list of package make dependencies
        ///  @param pkg a pointer to package
        ///  @return a reference to an internal list of alpm_depend_t structures.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_makedepends", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_pkg_get_makedepends(byte* pkg);

        /// <summary>
        ///  Returns the list of packages conflicting with pkg.
        ///  @param pkg a pointer to package
        ///  @return a reference to an internal list of alpm_depend_t structures.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_conflicts", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_pkg_get_conflicts(byte* pkg);

        /// <summary>
        ///  Returns the list of packages provided by pkg.
        ///  @param pkg a pointer to package
        ///  @return a reference to an internal list of alpm_depend_t structures.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_provides", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_pkg_get_provides(byte* pkg);

        /// <summary>
        ///  Returns the list of packages to be replaced by pkg.
        ///  @param pkg a pointer to package
        ///  @return a reference to an internal list of alpm_depend_t structures.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_replaces", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_pkg_get_replaces(byte* pkg);

        /// <summary>
        ///  Returns the list of files installed by pkg.
        ///  The filenames are relative to the install root,
        ///  and do not include leading slashes.
        ///  @param pkg a pointer to package
        ///  @return a pointer to a filelist object containing a count and an array of
        ///  package file objects
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_files", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_filelist_t* alpm_pkg_get_files(byte* pkg);

        /// <summary>
        ///  Returns the list of files backed up when installing pkg.
        ///  @param pkg a pointer to package
        ///  @return a reference to a list of alpm_backup_t objects
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_backup", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_pkg_get_backup(byte* pkg);

        /// <summary>
        ///  Returns the database containing pkg.
        ///  Returns a pointer to the alpm_db_t structure the package is
        ///  originating from, or NULL if the package was loaded from a file.
        ///  @param pkg a pointer to package
        ///  @return a pointer to the DB containing pkg, or NULL.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_db", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_pkg_get_db(byte* pkg);

        /// <summary>
        ///  Returns the base64 encoded package signature.
        ///  @param pkg a pointer to package
        ///  @return a reference to an internal string
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_base64_sig", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_pkg_get_base64_sig(byte* pkg);

        /// <summary>
        ///  Extracts package signature either from embedded package signature
        ///  or if it is absent then reads data from detached signature file.
        ///  @param pkg a pointer to package.
        ///  @param sig output parameter for signature data. Callee function allocates
        ///  a buffer needed for the signature data. Caller is responsible for
        ///  freeing this buffer.
        ///  @param sig_len output parameter for the signature data length.
        ///  @return 0 on success, negative number on error.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_sig", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_pkg_get_sig(byte* pkg, byte** sig, nuint* sig_len);

        /// <summary>
        ///  Returns the method used to validate a package during install.
        ///  @param pkg a pointer to package
        ///  @return an enum member giving the validation method
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_validation", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_pkg_get_validation(byte* pkg);

        /// <summary>
        ///  Gets the extended data field of a package.
        ///  @param pkg a pointer to package
        ///  @return a reference to a list of alpm_pkg_xdata_t objects
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_get_xdata", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_pkg_get_xdata(byte* pkg);

        /// <summary>
        ///  Returns whether the package has an install scriptlet.
        ///  @return 0 if FALSE, TRUE otherwise
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_has_scriptlet", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_pkg_has_scriptlet(byte* pkg);

        /// <summary>
        ///  Returns the size of the files that will be downloaded to install a
        ///  package.
        ///  @param newpkg the new package to upgrade to
        ///  @return the size of the download
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_download_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern CLong alpm_pkg_download_size(byte* newpkg);

        /// <summary>
        ///  Set install reason for a package in the local database.
        ///  The provided package object must be from the local database or this method
        ///  will fail. The write to the local database is performed immediately.
        ///  @param pkg the package to update
        ///  @param reason the new install reason
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_set_reason", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_pkg_set_reason(byte* pkg, _alpm_pkgreason_t reason);

        /// <summary>
        ///  Open a package changelog for reading.
        ///  Similar to fopen in functionality, except that the returned 'file
        ///  stream' could really be from an archive as well as from the database.
        ///  @param pkg the package to read the changelog of (either file or db)
        ///  @return a 'file stream' to the package changelog
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_changelog_open", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void* alpm_pkg_changelog_open(byte* pkg);

        /// <summary>
        ///  Read data from an open changelog 'file stream'.
        ///  Similar to fread in functionality, this function takes a buffer and
        ///  amount of data to read. If an error occurs pm_errno will be set.
        ///  @param ptr a buffer to fill with raw changelog data
        ///  @param size the size of the buffer
        ///  @param pkg the package that the changelog is being read from
        ///  @param fp a 'file stream' to the package changelog
        ///  @return the number of characters read, or 0 if there is no more data or an
        ///  error occurred.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_changelog_read", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint alpm_pkg_changelog_read(void* ptr, nuint size, byte* pkg, void* fp);

        /// <summary>
        ///  Close a package changelog for reading.
        ///  @param pkg the package to close the changelog of (either file or db)
        ///  @param fp the 'file stream' to the package changelog to close
        ///  @return 0 on success, -1 on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_changelog_close", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_pkg_changelog_close(byte* pkg, void* fp);

        /// <summary>
        ///  Open a package mtree file for reading.
        ///  @param pkg the local package to read the mtree of
        ///  @return an archive structure for the package mtree file
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_mtree_open", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern archive* alpm_pkg_mtree_open(byte* pkg);

        /// <summary>
        ///  Read next entry from a package mtree file.
        ///  @param pkg the package that the mtree file is being read from
        ///  @param archive the archive structure reading from the mtree file
        ///  @param entry an archive_entry to store the entry header information
        ///  @return 0 on success, 1 if end of archive is reached, -1 otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_mtree_next", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_pkg_mtree_next(byte* pkg, archive* archive, archive_entry** entry);

        /// <summary>
        ///  Close a package mtree file.
        ///  @param pkg the local package to close the mtree of
        ///  @param archive the archive to close
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_pkg_mtree_close", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_pkg_mtree_close(byte* pkg, archive* archive);

        /// <summary>
        ///  Returns the bitfield of flags for the current transaction.
        ///  @param handle the context handle
        ///  @return the bitfield of transaction flags
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_trans_get_flags", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_trans_get_flags(byte* handle);

        /// <summary>
        ///  Returns a list of packages added by the transaction.
        ///  @param handle the context handle
        ///  @return a list of alpm_pkg_t structures
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_trans_get_add", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_trans_get_add(byte* handle);

        /// <summary>
        ///  Returns the list of packages removed by the transaction.
        ///  @param handle the context handle
        ///  @return a list of alpm_pkg_t structures
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_trans_get_remove", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern _alpm_list_t* alpm_trans_get_remove(byte* handle);

        /// <summary>
        ///  Initialize the transaction.
        ///  @param handle the context handle
        ///  @param flags flags of the transaction (like nodeps, etc; see alpm_transflag_t)
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_trans_init", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_trans_init(byte* handle, int flags);

        /// <summary>
        ///  Prepare a transaction.
        ///  @param handle the context handle
        ///  @param data the address of an alpm_list where a list
        ///  of alpm_depmissing_t objects is dumped (conflicting packages)
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_trans_prepare", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_trans_prepare(byte* handle, _alpm_list_t** data);

        /// <summary>
        ///  Commit a transaction.
        ///  @param handle the context handle
        ///  @param data the address of an alpm_list where detailed description
        ///  of an error can be dumped (i.e. list of conflicting files)
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_trans_commit", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_trans_commit(byte* handle, _alpm_list_t** data);

        /// <summary>
        ///  Interrupt a transaction.
        ///  @param handle the context handle
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_trans_interrupt", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_trans_interrupt(byte* handle);

        /// <summary>
        ///  Release a transaction.
        ///  @param handle the context handle
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_trans_release", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_trans_release(byte* handle);

        /// <summary>
        ///  Search for packages to upgrade and add them to the transaction.
        ///  @param handle the context handle
        ///  @param enable_downgrade allow downgrading of packages if the remote version is lower
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_sync_sysupgrade", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_sync_sysupgrade(byte* handle, int enable_downgrade);

        /// <summary>
        ///  Add a package to the transaction.
        ///  If the package was loaded by alpm_pkg_load(), it will be freed upon
        ///  \link alpm_trans_release \endlink invocation.
        ///  @param handle the context handle
        ///  @param pkg the package to add
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_add_pkg", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_add_pkg(byte* handle, byte* pkg);

        /// <summary>
        ///  Add a package removal to the transaction.
        ///  @param handle the context handle
        ///  @param pkg the package to uninstall
        ///  @return 0 on success, -1 on error (pm_errno is set accordingly)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_remove_pkg", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_remove_pkg(byte* handle, byte* pkg);

        /// <summary>
        ///  Check for new version of pkg in syncdbs.
        /// 
        ///  If the same package appears multiple dbs only the first will be checked
        /// 
        ///  This only checks the syncdb for a newer version. It does not access the network at all.
        ///  See \link alpm_db_update \endlink to update a database.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_sync_get_new_version", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_sync_get_new_version(byte* pkg, _alpm_list_t* dbs_sync);

        /// <summary>
        ///  Get the md5 sum of file.
        ///  @param filename name of the file
        ///  @return the checksum on success, NULL on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_compute_md5sum", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_compute_md5sum(byte* filename);

        /// <summary>
        ///  Get the sha256 sum of file.
        ///  @param filename name of the file
        ///  @return the checksum on success, NULL on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_compute_sha256sum", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_compute_sha256sum(byte* filename);

        /// <summary>
        ///  Remove the database lock file
        ///  @param handle the context handle
        ///  @return 0 on success, -1 on error
        /// 
        ///  @note Safe to call from inside signal handlers.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_unlock", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_unlock(byte* handle);

        /// <summary>
        ///  Get the version of library.
        ///  @return the library version, e.g. "6.0.4"
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_version", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* alpm_version();

        /// <summary>
        ///  Get the capabilities of the library.
        ///  @return a bitmask of the capabilities
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_capabilities", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_capabilities();

        /// <summary>
        ///  Drop privileges by switching to a different user.
        ///  @param handle the context handle
        ///  @param sandboxuser the user to switch to
        ///  @param sandbox_path if non-NULL, restrict writes to this filesystem path
        ///  @return 0 on success, -1 on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "alpm_sandbox_setup_child", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int alpm_sandbox_setup_child(byte* handle, byte* sandboxuser, byte* sandbox_path);


    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct archive
    {
        public fixed byte _unused[1];
    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct archive_entry
    {
        public fixed byte _unused[1];
    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_list_t
    {
        public void* data;
        public _alpm_list_t* prev;
        public _alpm_list_t* next;
    }

    /// <summary>
    ///  File in a package
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_file_t
    {
        /// <summary>
        ///  Name of the file
        /// </summary>
        public byte* name;
        /// <summary>
        ///  Size of the file
        /// </summary>
        public CLong size;
        /// <summary>
        ///  The file's permissions
        /// </summary>
        public uint mode;
    }

    /// <summary>
    ///  Package filelist container
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_filelist_t
    {
        /// <summary>
        ///  Amount of files in the array
        /// </summary>
        public nuint count;
        /// <summary>
        ///  An array of files
        /// </summary>
        public _alpm_file_t* files;
    }

    /// <summary>
    ///  Package group
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_group_t
    {
        /// <summary>
        ///  group name
        /// </summary>
        public byte* name;
        /// <summary>
        ///  list of alpm_pkg_t packages
        /// </summary>
        public _alpm_list_t* packages;
    }

    /// <summary>
    ///  A PGP key
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_pgpkey_t
    {
        /// <summary>
        ///  The actual key data
        /// </summary>
        public void* data;
        /// <summary>
        ///  The key's fingerprint
        /// </summary>
        public byte* fingerprint;
        /// <summary>
        ///  UID of the key
        /// </summary>
        public byte* uid;
        /// <summary>
        ///  Name of the key's owner
        /// </summary>
        public byte* name;
        /// <summary>
        ///  Email of the key's owner
        /// </summary>
        public byte* email;
        /// <summary>
        ///  When the key was created
        /// </summary>
        public long created;
        /// <summary>
        ///  When the key expires
        /// </summary>
        public long expires;
        /// <summary>
        ///  The length of the key
        /// </summary>
        public uint length;
        /// <summary>
        ///  has the key been revoked
        /// </summary>
        public uint revoked;
        /// <summary>
        ///  A character representing the  encryption algorithm used by the public key
        /// 
        ///  ? = unknown
        ///  R = RSA
        ///  D = DSA
        ///  E = EDDSA
        /// </summary>
        public byte pubkey_algo;
    }

    /// <summary>
    ///  Signature result. Contains the key, status, and validity of a given
    ///  signature.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_sigresult_t
    {
        /// <summary>
        ///  The key of the signature
        /// </summary>
        public _alpm_pgpkey_t key;
        /// <summary>
        ///  The status of the signature
        /// </summary>
        public _alpm_sigstatus_t status;
        /// <summary>
        ///  The validity of the signature
        /// </summary>
        public _alpm_sigvalidity_t validity;
    }

    /// <summary>
    ///  Signature list. Contains the number of signatures found and a pointer to an
    ///  array of results. The array is of size count.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_siglist_t
    {
        /// <summary>
        ///  The amount of results in the array
        /// </summary>
        public nuint count;
        /// <summary>
        ///  An array of sigresults
        /// </summary>
        public _alpm_sigresult_t* results;
    }

    /// <summary>
    ///  The basic dependency type.
    /// 
    ///  This type is used throughout libalpm, not just for dependencies
    ///  but also conflicts and providers.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_depend_t
    {
        /// <summary>
        ///   Name of the provider to satisfy this dependency
        /// </summary>
        public byte* name;
        /// <summary>
        ///   Version of the provider to match against (optional)
        /// </summary>
        public byte* version;
        /// <summary>
        ///  A description of why this dependency is needed (optional)
        /// </summary>
        public byte* desc;
        /// <summary>
        ///  A hash of name (used internally to speed up conflict checks)
        /// </summary>
        public CULong name_hash;
        /// <summary>
        ///  How the version should match against the provider
        /// </summary>
        public _alpm_depmod_t mod_;
    }

    /// <summary>
    ///  Missing dependency.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_depmissing_t
    {
        /// <summary>
        ///  Name of the package that has the dependency
        /// </summary>
        public byte* target;
        /// <summary>
        ///  The dependency that was wanted
        /// </summary>
        public _alpm_depend_t* depend;
        /// <summary>
        ///  If the depmissing was caused by a conflict, the name of the package
        ///  that would be installed, causing the satisfying package to be removed
        /// </summary>
        public byte* causingpkg;
    }

    /// <summary>
    ///  A conflict that has occurred between two packages.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_conflict_t
    {
        /// <summary>
        ///  The first package
        /// </summary>
        public byte* package1;
        /// <summary>
        ///  The second package
        /// </summary>
        public byte* package2;
        /// <summary>
        ///  The conflict
        /// </summary>
        public _alpm_depend_t* reason;
    }

    /// <summary>
    ///  File conflict.
    /// 
    ///  A conflict that has happened due to a two packages containing the same file,
    ///  or a package contains a file that is already on the filesystem and not owned
    ///  by that package.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_fileconflict_t
    {
        /// <summary>
        ///  The name of the package that caused the conflict
        /// </summary>
        public byte* target;
        /// <summary>
        ///  The type of conflict
        /// </summary>
        public _alpm_fileconflicttype_t type_;
        /// <summary>
        ///  The name of the file that the package conflicts with
        /// </summary>
        public byte* file;
        /// <summary>
        ///  The name of the package that also owns the file if there is one
        /// </summary>
        public byte* ctarget;
    }

    /// <summary>
    ///  An event that may represent any event.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_event_any_t
    {
        /// <summary>
        ///  Type of event
        /// </summary>
        public _alpm_event_type_t type_;
    }

    /// <summary>
    ///  A package operation event occurred.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_event_package_operation_t
    {
        /// <summary>
        ///  Type of event
        /// </summary>
        public _alpm_event_type_t type_;
        /// <summary>
        ///  Type of operation
        /// </summary>
        public _alpm_package_operation_t operation;
        /// <summary>
        ///  Old package
        /// </summary>
        public byte* oldpkg;
        /// <summary>
        ///  New package
        /// </summary>
        public byte* newpkg;
    }

    /// <summary>
    ///  An optional dependency was removed.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_event_optdep_removal_t
    {
        /// <summary>
        ///  Type of event
        /// </summary>
        public _alpm_event_type_t type_;
        /// <summary>
        ///  Package with the optdep
        /// </summary>
        public byte* pkg;
        /// <summary>
        ///  Optdep being removed
        /// </summary>
        public _alpm_depend_t* optdep;
    }

    /// <summary>
    ///  A scriptlet was ran.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_event_scriptlet_info_t
    {
        /// <summary>
        ///  Type of event
        /// </summary>
        public _alpm_event_type_t type_;
        /// <summary>
        ///  Line of scriptlet output
        /// </summary>
        public byte* line;
    }

    /// <summary>
    ///  A database is missing.
    /// 
    ///  The database is registered but has not been downloaded
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_event_database_missing_t
    {
        /// <summary>
        ///  Type of event
        /// </summary>
        public _alpm_event_type_t type_;
        /// <summary>
        ///  Name of the database
        /// </summary>
        public byte* dbname;
    }

    /// <summary>
    ///  A package was downloaded.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_event_pkgdownload_t
    {
        /// <summary>
        ///  Type of event
        /// </summary>
        public _alpm_event_type_t type_;
        /// <summary>
        ///  Name of the file
        /// </summary>
        public byte* file;
    }

    /// <summary>
    ///  A pacnew file was created.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_event_pacnew_created_t
    {
        /// <summary>
        ///  Type of event
        /// </summary>
        public _alpm_event_type_t type_;
        /// <summary>
        ///  Whether the creation was result of a NoUpgrade or not
        /// </summary>
        public int from_noupgrade;
        /// <summary>
        ///  Old package
        /// </summary>
        public byte* oldpkg;
        /// <summary>
        ///  New Package
        /// </summary>
        public byte* newpkg;
        /// <summary>
        ///  Filename of the file without the .pacnew suffix
        /// </summary>
        public byte* file;
    }

    /// <summary>
    ///  A pacsave file was created.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_event_pacsave_created_t
    {
        /// <summary>
        ///  Type of event
        /// </summary>
        public _alpm_event_type_t type_;
        /// <summary>
        ///  Old package
        /// </summary>
        public byte* oldpkg;
        /// <summary>
        ///  Filename of the file without the .pacsave suffix
        /// </summary>
        public byte* file;
    }

    /// <summary>
    ///  pre/post transaction hooks are to be ran.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_event_hook_t
    {
        /// <summary>
        ///  Type of event
        /// </summary>
        public _alpm_event_type_t type_;
        /// <summary>
        ///  Type of hook
        /// </summary>
        public _alpm_hook_when_t when;
    }

    /// <summary>
    ///  A pre/post transaction hook was ran.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_event_hook_run_t
    {
        /// <summary>
        ///  Type of event
        /// </summary>
        public _alpm_event_type_t type_;
        /// <summary>
        ///  Name of hook
        /// </summary>
        public byte* name;
        /// <summary>
        ///  Description of hook to be outputted
        /// </summary>
        public byte* desc;
        /// <summary>
        ///  position of hook being run
        /// </summary>
        public nuint position;
        /// <summary>
        ///  total hooks being run
        /// </summary>
        public nuint total;
    }

    /// <summary>
    ///  Packages downloading about to start.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_event_pkg_retrieve_t
    {
        /// <summary>
        ///  Type of event
        /// </summary>
        public _alpm_event_type_t type_;
        /// <summary>
        ///  Number of packages to download
        /// </summary>
        public nuint num;
        /// <summary>
        ///  Total size of packages to download
        /// </summary>
        public CLong total_size;
    }

    /// <summary>
    ///  Events.
    ///  This is a union passed to the callback that allows the frontend to know
    ///  which type of event was triggered (via type). It is then possible to
    ///  typecast the pointer to the right structure, or use the union field, in order
    ///  to access event-specific data.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct _alpm_event_t
    {
        /// <summary>
        ///  Type of event it's always safe to access this.
        /// </summary>
        [FieldOffset(0)]
        public _alpm_event_type_t type_;
        /// <summary>
        ///  The any event type. It's always safe to access this.
        /// </summary>
        [FieldOffset(0)]
        public _alpm_event_any_t any;
        /// <summary>
        ///  Package operation
        /// </summary>
        [FieldOffset(0)]
        public _alpm_event_package_operation_t package_operation;
        /// <summary>
        ///  An optdept was remove
        /// </summary>
        [FieldOffset(0)]
        public _alpm_event_optdep_removal_t optdep_removal;
        /// <summary>
        ///  A scriptlet was ran
        /// </summary>
        [FieldOffset(0)]
        public _alpm_event_scriptlet_info_t scriptlet_info;
        /// <summary>
        ///  A database is missing
        /// </summary>
        [FieldOffset(0)]
        public _alpm_event_database_missing_t database_missing;
        /// <summary>
        ///  A package was downloaded
        /// </summary>
        [FieldOffset(0)]
        public _alpm_event_pkgdownload_t pkgdownload;
        /// <summary>
        ///  A pacnew file was created
        /// </summary>
        [FieldOffset(0)]
        public _alpm_event_pacnew_created_t pacnew_created;
        /// <summary>
        ///  A pacsave file was created
        /// </summary>
        [FieldOffset(0)]
        public _alpm_event_pacsave_created_t pacsave_created;
        /// <summary>
        ///  Pre/post transaction hooks are being ran
        /// </summary>
        [FieldOffset(0)]
        public _alpm_event_hook_t hook;
        /// <summary>
        ///  A hook was ran
        /// </summary>
        [FieldOffset(0)]
        public _alpm_event_hook_run_t hook_run;
        /// <summary>
        ///  Download packages
        /// </summary>
        [FieldOffset(0)]
        public _alpm_event_pkg_retrieve_t pkg_retrieve;
    }

    /// <summary>
    ///  A question that can represent any other question.
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_question_any_t
    {
        /// <summary>
        ///  Type of question
        /// </summary>
        public _alpm_question_type_t type_;
        /// <summary>
        ///  Answer
        /// </summary>
        public int answer;
    }

    /// <summary>
    ///  Should target in ignorepkg be installed anyway?
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_question_install_ignorepkg_t
    {
        /// <summary>
        ///  Type of question
        /// </summary>
        public _alpm_question_type_t type_;
        /// <summary>
        ///  Answer: whether or not to install pkg anyway
        /// </summary>
        public int install;
        /// <summary>
        ///  The ignored package that we are deciding whether to install
        /// </summary>
        public byte* pkg;
    }

    /// <summary>
    ///  Should a package be replaced?
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_question_replace_t
    {
        /// <summary>
        ///  Type of question
        /// </summary>
        public _alpm_question_type_t type_;
        /// <summary>
        ///  Answer: whether or not to replace oldpkg with newpkg
        /// </summary>
        public int replace;
        /// <summary>
        ///  Package to be replaced
        /// </summary>
        public byte* oldpkg;
        /// <summary>
        ///  Package to replace with.
        /// </summary>
        public byte* newpkg;
        /// <summary>
        ///  DB of newpkg
        /// </summary>
        public byte* newdb;
    }

    /// <summary>
    ///  Should a conflicting package be removed?
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_question_conflict_t
    {
        /// <summary>
        ///  Type of question
        /// </summary>
        public _alpm_question_type_t type_;
        /// <summary>
        ///  Answer: whether or not to remove conflict-&gt;package2
        /// </summary>
        public int remove;
        /// <summary>
        ///  Conflict info
        /// </summary>
        public _alpm_conflict_t* conflict;
    }

    /// <summary>
    ///  Should a corrupted package be deleted?
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_question_corrupted_t
    {
        /// <summary>
        ///  Type of question
        /// </summary>
        public _alpm_question_type_t type_;
        /// <summary>
        ///  Answer: whether or not to remove filepath
        /// </summary>
        public int remove;
        /// <summary>
        ///  File to remove
        /// </summary>
        public byte* filepath;
        /// <summary>
        ///  Error code indicating the reason for package invalidity
        /// </summary>
        public _alpm_errno_t reason;
    }

    /// <summary>
    ///  Should unresolvable targets be removed from the transaction?
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_question_remove_pkgs_t
    {
        /// <summary>
        ///  Type of question
        /// </summary>
        public _alpm_question_type_t type_;
        /// <summary>
        ///  Answer: whether or not to skip packages
        /// </summary>
        public int skip;
        /// <summary>
        ///  List of alpm_pkg_t* with unresolved dependencies
        /// </summary>
        public _alpm_list_t* packages;
    }

    /// <summary>
    ///  Provider selection
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_question_select_provider_t
    {
        /// <summary>
        ///  Type of question
        /// </summary>
        public _alpm_question_type_t type_;
        /// <summary>
        ///  Answer: which provider to use (index from providers)
        /// </summary>
        public int use_index;
        /// <summary>
        ///  List of alpm_pkg_t* as possible providers
        /// </summary>
        public _alpm_list_t* providers;
        /// <summary>
        ///  What providers provide for
        /// </summary>
        public _alpm_depend_t* depend;
    }

    /// <summary>
    ///  Should a key be imported?
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct _alpm_question_import_key_t
    {
        /// <summary>
        ///  Type of question
        /// </summary>
        public _alpm_question_type_t type_;
        /// <summary>
        ///  Answer: whether or not to import key
        /// </summary>
        public int import;
        /// <summary>
        ///  UID of the key to import
        /// </summary>
        public byte* uid;
        /// <summary>
        ///  Fingerprint the key to import
        /// </summary>
        public byte* fingerprint;
    }

    /// <summary>
    ///  Questions.
    ///  This is an union passed to the callback that allows the frontend to know
    ///  which type of question was triggered (via type). It is then possible to
    ///  typecast the pointer to the right structure, or use the union field, in order
    ///  to access question-specific data.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public unsafe partial struct _alpm_question_t
    {
        /// <summary>
        ///  The type of question. It's always safe to access this.
        /// </summary>
        [FieldOffset(0)]
        public _alpm_question_type_t type_;
        /// <summary>
        ///  A question that can represent any question.
        ///  It's always safe to access this.
        /// </summary>
        [FieldOffset(0)]
        public _alpm_question_any_t any;
        /// <summary>
        ///  Should target in ignorepkg be installed anyway?
        /// </summary>
        [FieldOffset(0)]
        public _alpm_question_install_ignorepkg_t install_ignorepkg;
        /// <summary>
        ///  Should a package be replaced?
        /// </summary>
        [FieldOffset(0)]
        public _alpm_question_replace_t replace;
        /// <summary>
        ///  Should a conflicting package be removed?
        /// </summary>
        [FieldOffset(0)]
        public _alpm_question_conflict_t conflict;
        /// <summary>
        ///  Should a corrupted package be deleted?
        /// </summary>
        [FieldOffset(0)]
        public _alpm_question_corrupted_t corrupted;
        /// <summary>
        ///  Should unresolvable targets be removed from the transaction?
        /// </summary>
        [FieldOffset(0)]
        public _alpm_question_remove_pkgs_t remove_pkgs;
        /// <summary>
        ///  Provider selection
        /// </summary>
        [FieldOffset(0)]
        public _alpm_question_select_provider_t select_provider;
        /// <summary>
        ///  Should a key be imported?
        /// </summary>
        [FieldOffset(0)]
        public _alpm_question_import_key_t import_key;
    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct __va_list_tag
    {
        public uint gp_offset;
        public uint fp_offset;
        public void* overflow_arg_area;
        public void* reg_save_area;
    }


    /// <summary>
    ///  libalpm's error type
    /// </summary>
    public enum _alpm_errno_t : uint
    {
        /// <summary>
        ///  No error
        /// </summary>
        ALPM_ERR_OK = 0,
        /// <summary>
        ///  Failed to allocate memory
        /// </summary>
        ALPM_ERR_MEMORY = 1,
        /// <summary>
        ///  A system error occurred
        /// </summary>
        ALPM_ERR_SYSTEM = 2,
        /// <summary>
        ///  Permmision denied
        /// </summary>
        ALPM_ERR_BADPERMS = 3,
        /// <summary>
        ///  Should be a file
        /// </summary>
        ALPM_ERR_NOT_A_FILE = 4,
        /// <summary>
        ///  Should be a directory
        /// </summary>
        ALPM_ERR_NOT_A_DIR = 5,
        /// <summary>
        ///  Function was called with invalid arguments
        /// </summary>
        ALPM_ERR_WRONG_ARGS = 6,
        /// <summary>
        ///  Insufficient disk space
        /// </summary>
        ALPM_ERR_DISK_SPACE = 7,
        /// <summary>
        ///  Handle should be null
        /// </summary>
        ALPM_ERR_HANDLE_NULL = 8,
        /// <summary>
        ///  Handle should not be null
        /// </summary>
        ALPM_ERR_HANDLE_NOT_NULL = 9,
        /// <summary>
        ///  Failed to acquire lock
        /// </summary>
        ALPM_ERR_HANDLE_LOCK = 10,
        /// <summary>
        ///  Failed to open database
        /// </summary>
        ALPM_ERR_DB_OPEN = 11,
        /// <summary>
        ///  Failed to create database
        /// </summary>
        ALPM_ERR_DB_CREATE = 12,
        /// <summary>
        ///  Database should not be null
        /// </summary>
        ALPM_ERR_DB_NULL = 13,
        /// <summary>
        ///  Database should be null
        /// </summary>
        ALPM_ERR_DB_NOT_NULL = 14,
        /// <summary>
        ///  The database could not be found
        /// </summary>
        ALPM_ERR_DB_NOT_FOUND = 15,
        /// <summary>
        ///  Database is invalid
        /// </summary>
        ALPM_ERR_DB_INVALID = 16,
        /// <summary>
        ///  Database has an invalid signature
        /// </summary>
        ALPM_ERR_DB_INVALID_SIG = 17,
        /// <summary>
        ///  The localdb is in a newer/older format than libalpm expects
        /// </summary>
        ALPM_ERR_DB_VERSION = 18,
        /// <summary>
        ///  Failed to write to the database
        /// </summary>
        ALPM_ERR_DB_WRITE = 19,
        /// <summary>
        ///  Failed to remove entry from database
        /// </summary>
        ALPM_ERR_DB_REMOVE = 20,
        /// <summary>
        ///  Server URL is in an invalid format
        /// </summary>
        ALPM_ERR_SERVER_BAD_URL = 21,
        /// <summary>
        ///  The database has no configured servers
        /// </summary>
        ALPM_ERR_SERVER_NONE = 22,
        /// <summary>
        ///  A transaction is already initialized
        /// </summary>
        ALPM_ERR_TRANS_NOT_NULL = 23,
        /// <summary>
        ///  A transaction has not been initialized
        /// </summary>
        ALPM_ERR_TRANS_NULL = 24,
        /// <summary>
        ///  Duplicate target in transaction
        /// </summary>
        ALPM_ERR_TRANS_DUP_TARGET = 25,
        /// <summary>
        ///  Duplicate filename in transaction
        /// </summary>
        ALPM_ERR_TRANS_DUP_FILENAME = 26,
        /// <summary>
        ///  A transaction has not been initialized
        /// </summary>
        ALPM_ERR_TRANS_NOT_INITIALIZED = 27,
        /// <summary>
        ///  Transaction has not been prepared
        /// </summary>
        ALPM_ERR_TRANS_NOT_PREPARED = 28,
        /// <summary>
        ///  Transaction was aborted
        /// </summary>
        ALPM_ERR_TRANS_ABORT = 29,
        /// <summary>
        ///  Failed to interrupt transaction
        /// </summary>
        ALPM_ERR_TRANS_TYPE = 30,
        /// <summary>
        ///  Tried to commit transaction without locking the database
        /// </summary>
        ALPM_ERR_TRANS_NOT_LOCKED = 31,
        /// <summary>
        ///  A hook failed to run
        /// </summary>
        ALPM_ERR_TRANS_HOOK_FAILED = 32,
        /// <summary>
        ///  Package not found
        /// </summary>
        ALPM_ERR_PKG_NOT_FOUND = 33,
        /// <summary>
        ///  Package is in ignorepkg
        /// </summary>
        ALPM_ERR_PKG_IGNORED = 34,
        /// <summary>
        ///  Package is invalid
        /// </summary>
        ALPM_ERR_PKG_INVALID = 35,
        /// <summary>
        ///  Package has an invalid checksum
        /// </summary>
        ALPM_ERR_PKG_INVALID_CHECKSUM = 36,
        /// <summary>
        ///  Package has an invalid signature
        /// </summary>
        ALPM_ERR_PKG_INVALID_SIG = 37,
        /// <summary>
        ///  Package does not have a signature
        /// </summary>
        ALPM_ERR_PKG_MISSING_SIG = 38,
        /// <summary>
        ///  Cannot open the package file
        /// </summary>
        ALPM_ERR_PKG_OPEN = 39,
        /// <summary>
        ///  Failed to remove package files
        /// </summary>
        ALPM_ERR_PKG_CANT_REMOVE = 40,
        /// <summary>
        ///  Package has an invalid name
        /// </summary>
        ALPM_ERR_PKG_INVALID_NAME = 41,
        /// <summary>
        ///  Package has an invalid architecture
        /// </summary>
        ALPM_ERR_PKG_INVALID_ARCH = 42,
        /// <summary>
        ///  Signatures are missing
        /// </summary>
        ALPM_ERR_SIG_MISSING = 43,
        /// <summary>
        ///  Signatures are invalid
        /// </summary>
        ALPM_ERR_SIG_INVALID = 44,
        /// <summary>
        ///  Dependencies could not be satisfied
        /// </summary>
        ALPM_ERR_UNSATISFIED_DEPS = 45,
        /// <summary>
        ///  Conflicting dependencies
        /// </summary>
        ALPM_ERR_CONFLICTING_DEPS = 46,
        /// <summary>
        ///  Files conflict
        /// </summary>
        ALPM_ERR_FILE_CONFLICTS = 47,
        /// <summary>
        ///  Download failed
        /// </summary>
        ALPM_ERR_RETRIEVE = 48,
        /// <summary>
        ///  Invalid Regex
        /// </summary>
        ALPM_ERR_INVALID_REGEX = 49,
        /// <summary>
        ///  Error in libarchive
        /// </summary>
        ALPM_ERR_LIBARCHIVE = 50,
        /// <summary>
        ///  Error in libcurl
        /// </summary>
        ALPM_ERR_LIBCURL = 51,
        /// <summary>
        ///  Error in external download program
        /// </summary>
        ALPM_ERR_EXTERNAL_DOWNLOAD = 52,
        /// <summary>
        ///  Error in gpgme
        /// </summary>
        ALPM_ERR_GPGME = 53,
        /// <summary>
        ///  Missing compile-time features
        /// </summary>
        ALPM_ERR_MISSING_CAPABILITY_SIGNATURES = 54,
    }

    /// <summary>
    ///  PGP signature verification status return codes
    /// </summary>
    public enum _alpm_sigstatus_t : uint
    {
        /// <summary>
        ///  Signature is valid
        /// </summary>
        ALPM_SIGSTATUS_VALID = 0,
        /// <summary>
        ///  The key has expired
        /// </summary>
        ALPM_SIGSTATUS_KEY_EXPIRED = 1,
        /// <summary>
        ///  The signature has expired
        /// </summary>
        ALPM_SIGSTATUS_SIG_EXPIRED = 2,
        /// <summary>
        ///  The key is not in the keyring
        /// </summary>
        ALPM_SIGSTATUS_KEY_UNKNOWN = 3,
        /// <summary>
        ///  The key has been disabled
        /// </summary>
        ALPM_SIGSTATUS_KEY_DISABLED = 4,
        /// <summary>
        ///  The signature is invalid
        /// </summary>
        ALPM_SIGSTATUS_INVALID = 5,
    }

    /// <summary>
    ///  The trust level of a PGP key
    /// </summary>
    public enum _alpm_sigvalidity_t : uint
    {
        /// <summary>
        ///  The signature is fully trusted
        /// </summary>
        ALPM_SIGVALIDITY_FULL = 0,
        /// <summary>
        ///  The signature is marginally trusted
        /// </summary>
        ALPM_SIGVALIDITY_MARGINAL = 1,
        /// <summary>
        ///  The signature is never trusted
        /// </summary>
        ALPM_SIGVALIDITY_NEVER = 2,
        /// <summary>
        ///  The signature has unknown trust
        /// </summary>
        ALPM_SIGVALIDITY_UNKNOWN = 3,
    }

    /// <summary>
    ///  Types of version constraints in dependency specs.
    /// </summary>
    public enum _alpm_depmod_t : uint
    {
        /// <summary>
        ///  No version constraint
        /// </summary>
        ALPM_DEP_MOD_ANY = 1,
        /// <summary>
        ///  Test version equality (package=x.y.z)
        /// </summary>
        ALPM_DEP_MOD_EQ = 2,
        /// <summary>
        ///  Test for at least a version (package&gt;=x.y.z)
        /// </summary>
        ALPM_DEP_MOD_GE = 3,
        /// <summary>
        ///  Test for at most a version (package&lt;=x.y.z)
        /// </summary>
        ALPM_DEP_MOD_LE = 4,
        /// <summary>
        ///  Test for greater than some version (package&gt;x.y.z)
        /// </summary>
        ALPM_DEP_MOD_GT = 5,
        /// <summary>
        ///  Test for less than some version (package&lt;x.y.z)
        /// </summary>
        ALPM_DEP_MOD_LT = 6,
    }

    /// <summary>
    ///  File conflict type.
    ///  Whether the conflict results from a file existing on the filesystem, or with
    ///  another target in the transaction.
    /// </summary>
    public enum _alpm_fileconflicttype_t : uint
    {
        /// <summary>
        ///  The conflict results with a another target in the transaction
        /// </summary>
        ALPM_FILECONFLICT_TARGET = 1,
        /// <summary>
        ///  The conflict results from a file existing on the filesystem
        /// </summary>
        ALPM_FILECONFLICT_FILESYSTEM = 2,
    }

    /// <summary>
    ///  Type of events.
    /// </summary>
    public enum _alpm_event_type_t : uint
    {
        /// <summary>
        ///  Dependencies will be computed for a package.
        /// </summary>
        ALPM_EVENT_CHECKDEPS_START = 1,
        /// <summary>
        ///  Dependencies were computed for a package.
        /// </summary>
        ALPM_EVENT_CHECKDEPS_DONE = 2,
        /// <summary>
        ///  File conflicts will be computed for a package.
        /// </summary>
        ALPM_EVENT_FILECONFLICTS_START = 3,
        /// <summary>
        ///  File conflicts were computed for a package.
        /// </summary>
        ALPM_EVENT_FILECONFLICTS_DONE = 4,
        /// <summary>
        ///  Dependencies will be resolved for target package.
        /// </summary>
        ALPM_EVENT_RESOLVEDEPS_START = 5,
        /// <summary>
        ///  Dependencies were resolved for target package.
        /// </summary>
        ALPM_EVENT_RESOLVEDEPS_DONE = 6,
        /// <summary>
        ///  Inter-conflicts will be checked for target package.
        /// </summary>
        ALPM_EVENT_INTERCONFLICTS_START = 7,
        /// <summary>
        ///  Inter-conflicts were checked for target package.
        /// </summary>
        ALPM_EVENT_INTERCONFLICTS_DONE = 8,
        /// <summary>
        ///  Processing the package transaction is starting.
        /// </summary>
        ALPM_EVENT_TRANSACTION_START = 9,
        /// <summary>
        ///  Processing the package transaction is finished.
        /// </summary>
        ALPM_EVENT_TRANSACTION_DONE = 10,
        /// <summary>
        ///  Package will be installed/upgraded/downgraded/re-installed/removed; See
        ///  alpm_event_package_operation_t for arguments.
        /// </summary>
        ALPM_EVENT_PACKAGE_OPERATION_START = 11,
        /// <summary>
        ///  Package was installed/upgraded/downgraded/re-installed/removed; See
        ///  alpm_event_package_operation_t for arguments.
        /// </summary>
        ALPM_EVENT_PACKAGE_OPERATION_DONE = 12,
        /// <summary>
        ///  Target package's integrity will be checked.
        /// </summary>
        ALPM_EVENT_INTEGRITY_START = 13,
        /// <summary>
        ///  Target package's integrity was checked.
        /// </summary>
        ALPM_EVENT_INTEGRITY_DONE = 14,
        /// <summary>
        ///  Target package will be loaded.
        /// </summary>
        ALPM_EVENT_LOAD_START = 15,
        /// <summary>
        ///  Target package is finished loading.
        /// </summary>
        ALPM_EVENT_LOAD_DONE = 16,
        /// <summary>
        ///  Scriptlet has printed information; See alpm_event_scriptlet_info_t for
        ///  arguments.
        /// </summary>
        ALPM_EVENT_SCRIPTLET_INFO = 17,
        /// <summary>
        ///  Database files will be downloaded from a repository.
        /// </summary>
        ALPM_EVENT_DB_RETRIEVE_START = 18,
        /// <summary>
        ///  Database files were downloaded from a repository.
        /// </summary>
        ALPM_EVENT_DB_RETRIEVE_DONE = 19,
        /// <summary>
        ///  Not all database files were successfully downloaded from a repository.
        /// </summary>
        ALPM_EVENT_DB_RETRIEVE_FAILED = 20,
        /// <summary>
        ///  Package files will be downloaded from a repository.
        /// </summary>
        ALPM_EVENT_PKG_RETRIEVE_START = 21,
        /// <summary>
        ///  Package files were downloaded from a repository.
        /// </summary>
        ALPM_EVENT_PKG_RETRIEVE_DONE = 22,
        /// <summary>
        ///  Not all package files were successfully downloaded from a repository.
        /// </summary>
        ALPM_EVENT_PKG_RETRIEVE_FAILED = 23,
        /// <summary>
        ///  Disk space usage will be computed for a package.
        /// </summary>
        ALPM_EVENT_DISKSPACE_START = 24,
        /// <summary>
        ///  Disk space usage was computed for a package.
        /// </summary>
        ALPM_EVENT_DISKSPACE_DONE = 25,
        /// <summary>
        ///  An optdepend for another package is being removed; See
        ///  alpm_event_optdep_removal_t for arguments.
        /// </summary>
        ALPM_EVENT_OPTDEP_REMOVAL = 26,
        /// <summary>
        ///  A configured repository database is missing; See
        ///  alpm_event_database_missing_t for arguments.
        /// </summary>
        ALPM_EVENT_DATABASE_MISSING = 27,
        /// <summary>
        ///  Checking keys used to create signatures are in keyring.
        /// </summary>
        ALPM_EVENT_KEYRING_START = 28,
        /// <summary>
        ///  Keyring checking is finished.
        /// </summary>
        ALPM_EVENT_KEYRING_DONE = 29,
        /// <summary>
        ///  Downloading missing keys into keyring.
        /// </summary>
        ALPM_EVENT_KEY_DOWNLOAD_START = 30,
        /// <summary>
        ///  Key downloading is finished.
        /// </summary>
        ALPM_EVENT_KEY_DOWNLOAD_DONE = 31,
        /// <summary>
        ///  A .pacnew file was created; See alpm_event_pacnew_created_t for arguments.
        /// </summary>
        ALPM_EVENT_PACNEW_CREATED = 32,
        /// <summary>
        ///  A .pacsave file was created; See alpm_event_pacsave_created_t for
        ///  arguments.
        /// </summary>
        ALPM_EVENT_PACSAVE_CREATED = 33,
        /// <summary>
        ///  Processing hooks will be started.
        /// </summary>
        ALPM_EVENT_HOOK_START = 34,
        /// <summary>
        ///  Processing hooks is finished.
        /// </summary>
        ALPM_EVENT_HOOK_DONE = 35,
        /// <summary>
        ///  A hook is starting
        /// </summary>
        ALPM_EVENT_HOOK_RUN_START = 36,
        /// <summary>
        ///  A hook has finished running.
        /// </summary>
        ALPM_EVENT_HOOK_RUN_DONE = 37,
    }

    /// <summary>
    ///  An enum over the kind of package operations.
    /// </summary>
    public enum _alpm_package_operation_t : uint
    {
        /// <summary>
        ///  Package (to be) installed. (No oldpkg)
        /// </summary>
        ALPM_PACKAGE_INSTALL = 1,
        /// <summary>
        ///  Package (to be) upgraded
        /// </summary>
        ALPM_PACKAGE_UPGRADE = 2,
        /// <summary>
        ///  Package (to be) re-installed
        /// </summary>
        ALPM_PACKAGE_REINSTALL = 3,
        /// <summary>
        ///  Package (to be) downgraded
        /// </summary>
        ALPM_PACKAGE_DOWNGRADE = 4,
        /// <summary>
        ///  Package (to be) removed (No newpkg)
        /// </summary>
        ALPM_PACKAGE_REMOVE = 5,
    }

    /// <summary>
    ///  Kind of hook.
    /// </summary>
    public enum _alpm_hook_when_t : uint
    {
        ALPM_HOOK_PRE_TRANSACTION = 1,
        ALPM_HOOK_POST_TRANSACTION = 2,
    }

    /// <summary>
    ///  Type of question.
    ///  Unlike the events or progress enumerations, this enum has bitmask values
    ///  so a frontend can use a bitmask map to supply preselected answers to the
    ///  different types of questions.
    /// </summary>
    public enum _alpm_question_type_t : uint
    {
        /// <summary>
        ///  Should target in ignorepkg be installed anyway?
        /// </summary>
        ALPM_QUESTION_INSTALL_IGNOREPKG = 1,
        /// <summary>
        ///  Should a package be replaced?
        /// </summary>
        ALPM_QUESTION_REPLACE_PKG = 2,
        /// <summary>
        ///  Should a conflicting package be removed?
        /// </summary>
        ALPM_QUESTION_CONFLICT_PKG = 4,
        /// <summary>
        ///  Should a corrupted package be deleted?
        /// </summary>
        ALPM_QUESTION_CORRUPTED_PKG = 8,
        /// <summary>
        ///  Should unresolvable targets be removed from the transaction?
        /// </summary>
        ALPM_QUESTION_REMOVE_PKGS = 16,
        /// <summary>
        ///  Provider selection
        /// </summary>
        ALPM_QUESTION_SELECT_PROVIDER = 32,
        /// <summary>
        ///  Should a key be imported?
        /// </summary>
        ALPM_QUESTION_IMPORT_KEY = 64,
    }

    /// <summary>
    ///  An enum over different kinds of progress alerts.
    /// </summary>
    public enum _alpm_progress_t : uint
    {
        /// <summary>
        ///  Package install
        /// </summary>
        ALPM_PROGRESS_ADD_START = 0,
        /// <summary>
        ///  Package upgrade
        /// </summary>
        ALPM_PROGRESS_UPGRADE_START = 1,
        /// <summary>
        ///  Package downgrade
        /// </summary>
        ALPM_PROGRESS_DOWNGRADE_START = 2,
        /// <summary>
        ///  Package reinstall
        /// </summary>
        ALPM_PROGRESS_REINSTALL_START = 3,
        /// <summary>
        ///  Package removal
        /// </summary>
        ALPM_PROGRESS_REMOVE_START = 4,
        /// <summary>
        ///  Conflict checking
        /// </summary>
        ALPM_PROGRESS_CONFLICTS_START = 5,
        /// <summary>
        ///  Diskspace checking
        /// </summary>
        ALPM_PROGRESS_DISKSPACE_START = 6,
        /// <summary>
        ///  Package Integrity checking
        /// </summary>
        ALPM_PROGRESS_INTEGRITY_START = 7,
        /// <summary>
        ///  Loading packages from disk
        /// </summary>
        ALPM_PROGRESS_LOAD_START = 8,
        /// <summary>
        ///  Checking signatures of packages
        /// </summary>
        ALPM_PROGRESS_KEYRING_START = 9,
    }

    /// <summary>
    ///  File download events.
    ///  These events are reported by ALPM via download callback.
    /// </summary>
    public enum _alpm_download_event_type_t : uint
    {
        /// <summary>
        ///  A download was started
        /// </summary>
        ALPM_DOWNLOAD_INIT = 0,
        /// <summary>
        ///  A download made progress
        /// </summary>
        ALPM_DOWNLOAD_PROGRESS = 1,
        /// <summary>
        ///  Download will be retried
        /// </summary>
        ALPM_DOWNLOAD_RETRY = 2,
        /// <summary>
        ///  A download completed
        /// </summary>
        ALPM_DOWNLOAD_COMPLETED = 3,
    }

    /// <summary>
    ///  Logging Levels
    /// </summary>
    public enum _alpm_loglevel_t : uint
    {
        /// <summary>
        ///  Error
        /// </summary>
        ALPM_LOG_ERROR = 1,
        /// <summary>
        ///  Warning
        /// </summary>
        ALPM_LOG_WARNING = 2,
        /// <summary>
        ///  Debug
        /// </summary>
        ALPM_LOG_DEBUG = 4,
        /// <summary>
        ///  Function
        /// </summary>
        ALPM_LOG_FUNCTION = 8,
    }

    /// <summary>
    ///  Package install reasons.
    /// </summary>
    public enum _alpm_pkgreason_t : uint
    {
        /// <summary>
        ///  Explicitly requested by the user.
        /// </summary>
        ALPM_PKG_REASON_EXPLICIT = 0,
        /// <summary>
        ///  Installed as a dependency for another package.
        /// </summary>
        ALPM_PKG_REASON_DEPEND = 1,
        /// <summary>
        ///  Failed parsing of local database
        /// </summary>
        ALPM_PKG_REASON_UNKNOWN = 2,
    }

    /// <summary>
    ///  Location a package object was loaded from.
    /// </summary>
    public enum _alpm_pkgfrom_t : uint
    {
        /// <summary>
        ///  Loaded from a file via \link alpm_pkg_load \endlink
        /// </summary>
        ALPM_PKG_FROM_FILE = 1,
        /// <summary>
        ///  From the local database
        /// </summary>
        ALPM_PKG_FROM_LOCALDB = 2,
        /// <summary>
        ///  From a sync database
        /// </summary>
        ALPM_PKG_FROM_SYNCDB = 3,
    }


}
